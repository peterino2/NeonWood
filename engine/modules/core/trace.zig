// trace module
//
// provides performance counters, trace capabilities and error
// logging to the rest of the engine.
//
// also provides a unified Trace context for error handling and recovery.
const std = @import("std");
const string = @import("string.zig");
const engineTime = @import("engineTime.zig");
const p2 = @import("lib/p2/algorithm.zig");

const ArrayListUnmanaged = std.ArrayListUnmanaged;
const AutoHashMap = std.AutoHashMap;

const MakeName = p2.MakeName;
const Name = p2.Name;
const Mutex = std.Thread.mutex;

const TraceEntry = struct {
    data: []const u8,
    timestamp: i128,

    pub fn allocPrint(self: @This(), allocator: std.mem.Allocator) ![]const u8 {
        var rv = try std.fmt.allocPrint(allocator, "t {d}: {s}", .{
            @as(f64, @floatFromInt(self.timestamp)) / (1000.0 * 1000.0 * 1000.0),
            self.data,
        });
        return rv;
    }

    pub fn debugPrint(self: @This(), allocator: std.mem.Allocator) void {
        var s = self.allocPrint(allocator) catch return;
        defer allocator.free(s);
        std.debug.print("{s}\n", .{s});
    }
};

pub const TraceMode = enum { single, multi };

const Trace = struct {
    name: Name,
    data: ArrayListUnmanaged(TraceEntry) = .{},
    mutex: std.Thread.Mutex = .{},
    threadingMode: TraceMode = .single,
    startTimestamp: i128 = 0,

    // Add a trace entry to this trace.
    // the data slice is now considered owned by the trace.
    pub fn addEntry(self: *@This(), allocator: std.mem.Allocator, data: []const u8) !*TraceEntry {
        var entry = TraceEntry{
            .data = data,
            .timestamp = engineTime.getEngineTimeStamp() - self.startTimestamp,
        };

        if (self.threadingMode == .multi) {
            self.mutex.lock();
        }

        try self.data.append(allocator, entry);
        return &self.data.items[self.data.items.len - 1];
    }

    // Adds an entry to this trace, copies the string slice
    pub fn addEntryCopy(self: *@This(), allocator: std.mem.Allocator, data: []const u8) !*TraceEntry {
        var d = try string.dupeString(allocator, data);
        return try self.addEntry(allocator, d);
    }

    // Adds an entry by fmt.
    pub fn addEntryFmt(
        self: *@This(),
        allocator: std.mem.Allocator,
        comptime fmt: []const u8,
        args: anytype,
    ) !*TraceEntry {
        var f = try std.fmt.allocPrint(allocator, fmt, args);
        return try self.addEntry(allocator, f);
    }

    // Higher level trace fmt, properly handles data threading.
    // does not provide the ability to push meta data onto the trace after the fact.
    pub fn traceFmt(self: *@This(), allocator: std.mem.Allocator, comptime fmt: []const u8, args: anytype) !void {
        _ = try self.addEntryFmt(allocator, fmt, args);
        if (self.threadingMode == .multi) {
            self.release();
        }
    }

    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        self.data.deinit(allocator);
    }

    // If the threading mode is not single,
    // then the data reference generated by teh addEntry* functions
    pub fn release(self: *@This()) void {
        self.mutex.unlock();
    }

    pub fn setTraceMode(self: *@This(), mode: TraceMode) void {
        var threadingMode = self.threadingMode;

        if (threadingMode == .multi) {
            self.mutex.lock();
        }

        self.threadingMode = mode;

        if (threadingMode == .multi) {
            self.mutex.unlock();
        }
    }

    pub fn printTraceStats(self: @This(), allocator: std.mem.Allocator) void {
        std.debug.print("trace id={s} count={d}\n", .{ self.name.utf8, self.data.items.len });
        for (self.data.items) |entry| {
            entry.debugPrint(allocator);
        }
    }
};

const DefaultContextName = MakeName("default");

pub const TracesContext = struct {
    allocator: std.mem.Allocator,
    defaultTrace: *Trace,
    traces: std.AutoHashMapUnmanaged(u32, *Trace),

    // Initializes a trace collection context with a single trace list
    pub fn init(allocator: std.mem.Allocator) @This() {
        var rv = @This(){
            .allocator = allocator,
            .defaultTrace = allocator.create(Trace) catch unreachable,
            .traces = .{},
        };

        rv.defaultTrace.* = .{
            .name = MakeName("default"),
            .startTimestamp = engineTime.getEngineTimeStamp(),
        };

        rv.traces.put(
            allocator,
            DefaultContextName.hash,
            rv.defaultTrace,
        ) catch unreachable;

        return rv;
    }

    pub fn deinit(self: *@This()) void {
        self.allocator.destroy(self.defaultTrace);
        self.traces.deinit(self.allocator);
        self.allocator.destroy(self);
    }
};
